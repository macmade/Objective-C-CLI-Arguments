/*******************************************************************************
 * Copyright (c) 2010, Jean-David Gadina - www.xs-labs.com
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

#import <Foundation/Foundation.h>
#import "CLIArguments.h"

@implementation CLIArguments

- ( id )init
{
    if( ( self = [ super init ] ) )
    {
        /* Gets informations about the current process, so we can retrieve the command line arguments */
        process        = [ NSProcessInfo processInfo ];
        
        /* Initialization of the instance variables */
        arguments      = [ [ NSMutableArray arrayWithCapacity: 10 ] retain ];
        valueArguments = [ [ NSMutableDictionary dictionaryWithCapacity: 10 ] retain ];
        flagArguments  = [ [ NSMutableDictionary dictionaryWithCapacity: 10 ] retain ];
    }
    
    return self;
}

- ( void )dealloc
{
    [ arguments release ];
    [ valueArguments release ];
    [ flagArguments release ];
    [ super dealloc ];
}

- ( NSString * )description
{
    NSString * object;
    NSString * description;
    
    /* Object type and memory address */
    object      = [ super description ];
    
    /* Displays all the arguments to the console */
    description = [ NSString stringWithFormat:  @"%@\n\nFlag arguments:\n%@\n\nValue arguments:\n%@\n\nOther arguments:\n%@",
                                                object,
                                                [ flagArguments allKeys ],
                                                valueArguments,
                                                arguments
    ];
    
    return description;
}

- ( id )initWithFlagArguments: ( NSArray * )fargs valueArguments: ( NSArray * )vargs
{
    NSArray    * args;
    NSString   * arg;
    NSString   * key;
    NSUInteger i;
    NSRange    range;
    
    if( ( self = [ self init ] ) )
    {
        /* Array with the command line arguments passed to the current process */
        args = [ process arguments ];
        
        /* Processes each argument */
        for( i = 1; i < [ args count ]; i++ )
        {
            /* Raw argument value */
            arg   = [ args objectAtIndex: i ];
            
            /* Detects if the argument contains an '=' sign, meaning its value directly follows */
            range = [ arg rangeOfString: @"=" ];
            
            /* Long argument name, beginning with '--' */
            if( [ arg length ] >= 2 && [ [ arg substringToIndex: 2 ] isEqualToString: @"--" ] )
            {
                /* Retrieves the argument key (without the '--'), by splitting the string if necessary (for the '=' notation only) */
                key = ( range.location == ( NSUInteger )NSIntegerMax ) ? [ arg substringFromIndex: 2 ] : [ arg substringWithRange: NSMakeRange( 2, range.location - 2 ) ];
            }
            
            /* Short argument name, beginning with - */
            else if( [ [ arg substringToIndex: 1 ] isEqualToString: @"-" ] )
            {
                /* Retrieves the argument key (without the '-'), by splitting the string if necessary (for the '=' notation only) */
                key = ( range.location == ( NSUInteger )NSIntegerMax ) ? [ arg substringFromIndex: 1 ] : [ arg substringWithRange: NSMakeRange( 1, range.location - 1 ) ];
            }
            else
            {
                /* Unnamed argument */
                key = nil;
            }
            
            /* Checks if the current argument is a flag argument (no value) */
            if( key && [ fargs containsObject: key ] )
            {
                /* Flag is set */
                [ flagArguments setObject: [ NSNull null ] forKey: key ];
                
                /* Done - Process the next argument */
                continue;
            }
            
            /* Checks if the current argument must have a value */
            if( key && [ vargs containsObject: key ] )
            {
                /* Argument has an '=' sign */
                if( range.location != ( NSUInteger )NSIntegerMax )
                {
                    /* Stores the argument value */
                    [ valueArguments setObject: [ arg substringFromIndex: range.location + 1 ] forKey: key ];
                }
                
                /* No '=' sign - value follows */
                else if( i < ( [ args count ] - 1 ) )
                {
                    /* Stores the argument value */
                    [ valueArguments setObject: [ args objectAtIndex: i + 1 ] forKey: key ];
                    
                    /* Moves to the next argument (bypass the current value) */
                    i++;
                }
                
                /* Done - Process the next argument */
                continue;
            }
            
            /* Unnamed argument - Stores it */
            [ arguments addObject: arg ];
        }
    }
    
    return self;
}

- ( NSArray * )arguments
{
    return [ NSArray arrayWithArray: arguments ];
}

- ( BOOL )hasFlag: ( NSString * )name
{
    return ( [ flagArguments objectForKey: name ] != nil );
}

- ( BOOL )boolForArgument: ( NSString * )name
{
    if( [ valueArguments objectForKey: name ] != nil )
    {
        return [ [ valueArguments objectForKey: name ] boolValue ];
    }
    
    return NO;
}

- ( int )intForArgument: ( NSString * )name
{
    if( [ valueArguments objectForKey: name ] != nil )
    {
        return [ [ valueArguments objectForKey: name ] intValue ];
    }
    
    return ( int )0;
}

- ( long long )longLongForArgument: ( NSString * )name
{
    if( [ valueArguments objectForKey: name ] != nil )
    {
        return [ [ valueArguments objectForKey: name ] longLongValue ];
    }
    
    return ( long long )0;
}

- ( NSInteger )integerForArgument: ( NSString * )name
{
    if( [ valueArguments objectForKey: name ] != nil )
    {
        return [ [ valueArguments objectForKey: name ] integerValue ];
    }
    
    return ( NSInteger )0;
}

- ( float )floatForArgument: ( NSString * )name
{
    if( [ valueArguments objectForKey: name ] != nil )
    {
        return [ [ valueArguments objectForKey: name ] floatValue ];
    }
    
    return ( float )0;
}

- ( double )doubleForArgument: ( NSString * )name
{
    if( [ valueArguments objectForKey: name ] != nil )
    {
        return [ [ valueArguments objectForKey: name ] doubleValue ];
    }
    
    return ( double )0;
}

- ( NSString * )stringForArgument: ( NSString * )name
{
    return [ valueArguments objectForKey: name ];
}

@end
